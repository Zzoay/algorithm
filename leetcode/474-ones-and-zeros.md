# 一和零

## 题目

[原题地址](https://leetcode-cn.com/problems/degree-of-an-array/)

给你一个二进制字符串数组 strs 和两个整数 m 和 n 。

请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。

如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。

**示例 1：**

```markdown
输入：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3

输出：4

解释：最多有 5 个 0 和 3 个 1 的最大子集是 {"10","0001","1","0"} ，因此答案是 4 。
其他满足题意但较小的子集包括 {"0001","1"} 和 {"10","1","0"} 。{"111001"} 不满足题
意，因为它含 4 个 1 ，大于 n 的值 3 。
```

**示例 2：**

```markdown
输入：strs = ["10", "0", "1"], m = 1, n = 1

输出：2

解释：最大的子集是 {"0", "1"} ，所以答案是 2 。
```

提示：

- 1 <= strs.length <= 600
- 1 <= strs[i].length <= 100
- strs[i] 仅由 '0' 和 '1' 组成
- 1 <= m, n <= 100

## 题解

这是一道背包问题，每个字符串为一个物品，价值为1，同时有0和1两种'重量'，因此可以用**动态规划**的方法解决。

首先确定dp数组的定义：dp[i][j]表示strs从0到目前位置的最大子集的大小，也即背包中放了多少物品，i和j分别代表0元素和1元素个数的容量的背包。

dp数组的初始化比较简单，dp[0][0]代表背包的0和1的容量都为0，所以能放0个物品，即dp[0][0]=0。

然后我们需要迭代地求解dp[i][j]，由于到当前位置的dp[i][j]由前一个位置的dp[i][j]所决定，因此为避免重复，我们需要从后往前迭代。对于每一个dp[i][j]来说，只有两种选择，

- 不将当前物品放入背包，也即复制是上一个位置的dp[i][j]；
- 将当前物品放入背包，那么此时需要去找0元素容量为i-cnt0，并且1元素容量为j-cnt1的背包，其中cnt0和cnt1分别代表当前字符串的0和1的数目，在原来基础上+1，即dp[i-cnt0][j-cnt1]+1。

只需要选择能装更多东西（更大）的那个即可，因此，dp[i][j] = max(dp[i][j], dp[i-cnt0][j-cnt1]+1);

## 代码

```c++
class Solution {
public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        vector<vector<int>> dp(m + 1, vector<int> (n + 1, 0));
        for(auto s: strs){
            int cnt1=0, cnt0=0;
            for(auto c: s){
                if(c == '1') cnt1++;
                else cnt0++;
            }

            for(int i=m; i>=cnt0; i--){
                for(int j=n; j>=cnt1; j--){
                    dp[i][j] = max(dp[i][j], dp[i-cnt0][j-cnt1]+1);
                }
            }
        }

        return dp[m][n];
    }
};
```
